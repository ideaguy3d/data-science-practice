<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Trees & Graphs Playground (Interview Prep)</title>
  <style>
    :root { --bg:#0b1020; --panel:#111a33; --ink:#e8eeff; --muted:#a9b6e8; --accent:#7aa2ff; --danger:#ff6b6b; }
    * { box-sizing:border-box; }
    body { margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; background:var(--bg); color:var(--ink); }
    header { padding:16px 18px; border-bottom:1px solid rgba(255,255,255,.08); display:flex; gap:14px; align-items:center; flex-wrap:wrap; }
    header h1 { margin:0; font-size:16px; letter-spacing:.2px; }
    header .hint { color:var(--muted); font-size:12px; }
    main { display:grid; grid-template-columns: 420px 1fr; gap:14px; padding:14px; }
    @media (max-width: 980px) { main { grid-template-columns: 1fr; } }
    .card { background:var(--panel); border:1px solid rgba(255,255,255,.08); border-radius:14px; padding:12px; }
    .card h2 { margin:0 0 10px; font-size:14px; }
    .row { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    label { font-size:12px; color:var(--muted); display:block; margin:8px 0 4px; }
    input, select, textarea {
      width:100%;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10);
      color:var(--ink);
      border-radius:10px;
      padding:9px 10px;
      outline:none;
      font-size:13px;
    }
    textarea { min-height:110px; resize:vertical; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    button {
      background:rgba(122,162,255,.16);
      border:1px solid rgba(122,162,255,.45);
      color:var(--ink);
      border-radius:12px;
      padding:9px 10px;
      font-size:13px;
      cursor:pointer;
    }
    button:hover { background:rgba(122,162,255,.22); }
    button.secondary { background:rgba(255,255,255,.08); border-color:rgba(255,255,255,.14); }
    button.danger { background:rgba(255,107,107,.16); border-color:rgba(255,107,107,.50); }
    .split { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    .pill { display:inline-flex; gap:8px; align-items:center; padding:6px 10px; border-radius:999px; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.08); font-size:12px; color:var(--muted); }
    .pill b { color:var(--ink); font-weight:600; }
    .out { white-space:pre-wrap; background:rgba(0,0,0,.25); border:1px solid rgba(255,255,255,.08); border-radius:12px; padding:10px; font-size:12px; line-height:1.45; }
    .vizWrap { height: 520px; }
    svg { width:100%; height:100%; background:rgba(0,0,0,.18); border-radius:12px; border:1px solid rgba(255,255,255,.08); }
    .small { font-size:12px; color:var(--muted); }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; font-size:11px; padding:2px 6px; border:1px solid rgba(255,255,255,.2); border-radius:6px; background:rgba(255,255,255,.06); }
  </style>
</head>
<body>
<header>
  <h1>Trees & Graphs Playground</h1>
  <div class="hint">Save as <span class="kbd">trees_graphs_playground.html</span> and open in your browser. Everything runs locally.</div>
  <div class="pill"><b>Mode</b> <span id="modeLabel">Graph</span></div>
  <div class="pill"><b>Tip</b> Use BFS for shortest path in unweighted graphs.</div>
</header>

<main>
  <section class="card">
    <h2>1) Build data</h2>

    <div class="row">
      <button id="btnModeGraph">Graph</button>
      <button id="btnModeTree" class="secondary">Tree</button>
      <button id="btnLoadExample" class="secondary">Load example</button>
      <button id="btnClear" class="danger">Clear</button>
    </div>

    <label>Input format</label>
    <div class="small" id="formatHelp"></div>

    <label for="inputEdges">Data input</label>
    <textarea id="inputEdges" spellcheck="false" class="mono"></textarea>

    <div class="split">
      <div>
        <label for="startNode">Start node</label>
        <input id="startNode" value="A" />
      </div>
      <div>
        <label for="targetNode">Target node (optional)</label>
        <input id="targetNode" value="F" />
      </div>
    </div>

    <label>Graph settings</label>
    <div class="row">
      <label class="pill" style="margin:0;">
        <input type="checkbox" id="undirected" checked style="width:auto; margin:0 8px 0 0;">
        Undirected
      </label>
    </div>

    <hr style="border:none;border-top:1px solid rgba(255,255,255,.08); margin:12px 0;">

    <h2>2) Run algorithms</h2>
    <div class="row">
      <button id="btnBFS">BFS</button>
      <button id="btnDFS">DFS</button>
      <button id="btnShortest">Shortest path (BFS)</button>
      <button id="btnComponents" class="secondary">Connected components</button>
      <button id="btnCycle" class="secondary">Cycle detect</button>
    </div>

    <div id="treeButtons" style="display:none; margin-top:10px;">
      <div class="row">
        <button id="btnPre">Tree: Preorder</button>
        <button id="btnIn">Tree: Inorder</button>
        <button id="btnPost">Tree: Postorder</button>
        <button id="btnLevel">Tree: Level-order</button>
      </div>
      <div class="small" style="margin-top:8px;">
        Inorder is most meaningful for <b>binary search trees</b>, but still good practice.
      </div>
    </div>

    <label>Output</label>
    <div class="out mono" id="output"></div>

    <label>Step-by-step trace</label>
    <div class="out mono" id="trace"></div>
  </section>

  <section class="card">
    <h2>Visualization</h2>
    <div class="small" style="margin-bottom:10px;">
      Shows nodes + edges. When you run BFS/DFS, visited nodes highlight in order.
    </div>
    <div class="vizWrap">
      <svg id="viz" viewBox="0 0 1000 520" xmlns="http://www.w3.org/2000/svg"></svg>
    </div>
    <div class="small" style="margin-top:10px;">
      You can edit the input and re-run. This is intentionally simple so you focus on algorithms, not UI.
    </div>
  </section>
</main>

<script>
/*
  Trees & Graphs Playground
  - Graph input format:
      Each line: "U V"  or "U V W"
      W is ignored for now (we focus on unweighted algorithms first).
      Example:
        A B
        A C
        B D
        C E
        E F

  - Tree input format:
      Each line: "Parent -> Left,Right" (either child can be blank)
      Example (binary tree):
        A -> B,C
        B -> D,E
        C -> ,F
        D -> ,
        E -> ,
        F -> ,

  Google-style interview focus:
  - BFS / DFS fundamentals (iterative + recursive patterns)
  - shortest path in unweighted graph (BFS + parent map)
  - connected components
  - cycle detection (undirected via parent tracking)
  - tree traversals
*/

const state = {
  mode: "graph", // "graph" | "tree"
  undirected: true,
  graph: new Map(),     // adjacency list: node -> Set(neighbors)
  tree: new Map(),      // node -> {left, right}
  nodes: [],            // ordered node list for viz
  edges: [],            // edge list for viz
  positions: new Map(), // node -> {x,y}
};

const el = {
  modeLabel: document.getElementById("modeLabel"),
  formatHelp: document.getElementById("formatHelp"),
  inputEdges: document.getElementById("inputEdges"),
  startNode: document.getElementById("startNode"),
  targetNode: document.getElementById("targetNode"),
  undirected: document.getElementById("undirected"),
  output: document.getElementById("output"),
  trace: document.getElementById("trace"),
  viz: document.getElementById("viz"),
  treeButtons: document.getElementById("treeButtons"),
};

document.getElementById("btnModeGraph").addEventListener("click", () => setMode("graph"));
document.getElementById("btnModeTree").addEventListener("click", () => setMode("tree"));
document.getElementById("btnLoadExample").addEventListener("click", loadExample);
document.getElementById("btnClear").addEventListener("click", clearAll);

document.getElementById("btnBFS").addEventListener("click", runBFS);
document.getElementById("btnDFS").addEventListener("click", runDFS);
document.getElementById("btnShortest").addEventListener("click", runShortestPath);
document.getElementById("btnComponents").addEventListener("click", runComponents);
document.getElementById("btnCycle").addEventListener("click", runCycleDetect);

document.getElementById("btnPre").addEventListener("click", () => runTreeTraversal("pre"));
document.getElementById("btnIn").addEventListener("click", () => runTreeTraversal("in"));
document.getElementById("btnPost").addEventListener("click", () => runTreeTraversal("post"));
document.getElementById("btnLevel").addEventListener("click", () => runTreeTraversal("level"));

el.undirected.addEventListener("change", () => {
  state.undirected = el.undirected.checked;
  rebuild();
});

setMode("graph");
loadExample();

function setMode(mode) {
  state.mode = mode;
  el.modeLabel.textContent = mode === "graph" ? "Graph" : "Tree";
  el.treeButtons.style.display = mode === "tree" ? "block" : "none";
  el.undirected.parentElement.style.display = mode === "graph" ? "inline-flex" : "none";

  const graphHelp = `
Graph (adjacency list). Each line: <b>U V</b> (optionally <b>U V W</b>).
Example:
<span class="mono">A B
A C
B D
C E
E F</span>
`;
  const treeHelp = `
Binary Tree. Each line: <b>Parent -> Left,Right</b>. Either side can be blank.
Example:
<span class="mono">A -> B,C
B -> D,E
C -> ,F</span>
`;
  el.formatHelp.innerHTML = mode === "graph" ? graphHelp : treeHelp;

  // Toggle button styling
  document.getElementById("btnModeGraph").className = mode === "graph" ? "" : "secondary";
  document.getElementById("btnModeTree").className  = mode === "tree"  ? "" : "secondary";

  rebuild();
}

function clearAll() {
  el.inputEdges.value = "";
  el.output.textContent = "";
  el.trace.textContent = "";
  state.graph.clear();
  state.tree.clear();
  state.nodes = [];
  state.edges = [];
  state.positions.clear();
  draw([]);
}

function loadExample() {
  if (state.mode === "graph") {
    el.inputEdges.value = [
      "A B",
      "A C",
      "B D",
      "B E",
      "C E",
      "E F",
    ].join("\n");
    el.startNode.value = "A";
    el.targetNode.value = "F";
  } else {
    el.inputEdges.value = [
      "A -> B,C",
      "B -> D,E",
      "C -> ,F",
      "D -> ,",
      "E -> ,",
      "F -> ,",
    ].join("\n");
    el.startNode.value = "A";
    el.targetNode.value = "";
  }
  rebuild();
}

function rebuild() {
  el.output.textContent = "";
  el.trace.textContent = "";
  if (state.mode === "graph") parseGraph();
  else parseTree();

  computeLayout();
  draw([]);
}

function parseGraph() {
  state.graph.clear();
  state.edges = [];
  const lines = el.inputEdges.value.split("\n").map(s => s.trim()).filter(Boolean);

  const addEdge = (u, v) => {
    if (!state.graph.has(u)) state.graph.set(u, new Set());
    if (!state.graph.has(v)) state.graph.set(v, new Set());
    state.graph.get(u).add(v);
    if (state.undirected) state.graph.get(v).add(u);
    state.edges.push([u, v]);
  };

  for (const line of lines) {
    const parts = line.split(/\s+/);
    if (parts.length < 2) continue;
    const u = parts[0];
    const v = parts[1];
    addEdge(u, v);
  }

  state.nodes = Array.from(state.graph.keys()).sort();
}

function parseTree() {
  state.tree.clear();
  state.edges = [];

  const lines = el.inputEdges.value.split("\n").map(s => s.trim()).filter(Boolean);

  const ensureNode = (n) => {
    if (!n) return;
    if (!state.tree.has(n)) state.tree.set(n, { left: null, right: null });
  };

  for (const line of lines) {
    const m = line.match(/^(.+?)\s*->\s*(.*)$/);
    if (!m) continue;
    const parent = m[1].trim();
    const rest = m[2].trim();
    const [leftRaw, rightRaw] = rest.split(",").map(x => (x ?? "").trim());

    ensureNode(parent);
    const node = state.tree.get(parent);

    const left = leftRaw || null;
    const right = rightRaw || null;

    if (left) ensureNode(left);
    if (right) ensureNode(right);

    node.left = left;
    node.right = right;

    if (left) state.edges.push([parent, left]);
    if (right) state.edges.push([parent, right]);
  }

  state.nodes = Array.from(state.tree.keys()).sort();
}

function neighbors(node) {
  if (state.mode !== "graph") return [];
  return state.graph.has(node) ? Array.from(state.graph.get(node)).sort() : [];
}

function runBFS() {
  rebuildIfDirty();
  if (state.mode !== "graph") return setOut("BFS is for graphs here. Switch to Graph mode.");

  const start = el.startNode.value.trim();
  if (!start) return setOut("Enter a start node.");
  if (!state.graph.has(start)) return setOut(`Start node "${start}" not found in graph.`);

  const q = [start];
  const visited = new Set([start]);
  const order = [];
  const trace = [];

  trace.push(`BFS(start=${start})`);
  trace.push(`queue = [${q.join(", ")}]`);

  while (q.length) {
    const cur = q.shift();
    order.push(cur);
    trace.push(`pop ${cur}`);

    for (const nxt of neighbors(cur)) {
      if (!visited.has(nxt)) {
        visited.add(nxt);
        q.push(nxt);
        trace.push(`  visit ${nxt} (enqueue)`);
      }
    }
    trace.push(`queue = [${q.join(", ")}]`);
  }

  setOut(`BFS order: ${order.join(" -> ")}`, trace.join("\n"));
  animateVisit(order);
}

function runDFS() {
  rebuildIfDirty();
  if (state.mode !== "graph") return setOut("DFS is for graphs here. Switch to Graph mode.");

  const start = el.startNode.value.trim();
  if (!start) return setOut("Enter a start node.");
  if (!state.graph.has(start)) return setOut(`Start node "${start}" not found in graph.`);

  const stack = [start];
  const visited = new Set();
  const order = [];
  const trace = [];
  trace.push(`DFS iterative (stack) start=${start}`);
  trace.push(`stack = [${stack.join(", ")}]`);

  while (stack.length) {
    const cur = stack.pop();
    trace.push(`pop ${cur}`);
    if (visited.has(cur)) {
      trace.push(`  already visited, continue`);
      continue;
    }
    visited.add(cur);
    order.push(cur);

    // push neighbors in reverse sorted order so traversal looks stable
    const nbrs = neighbors(cur);
    for (let i = nbrs.length - 1; i >= 0; i--) {
      const nxt = nbrs[i];
      if (!visited.has(nxt)) {
        stack.push(nxt);
        trace.push(`  push ${nxt}`);
      }
    }
    trace.push(`stack = [${stack.join(", ")}]`);
  }

  setOut(`DFS order: ${order.join(" -> ")}`, trace.join("\n"));
  animateVisit(order);
}

function runShortestPath() {
  rebuildIfDirty();
  if (state.mode !== "graph") return setOut("Shortest path here is for unweighted graphs. Switch to Graph mode.");

  const start = el.startNode.value.trim();
  const target = el.targetNode.value.trim();
  if (!start || !target) return setOut("Enter both Start node and Target node.");
  if (!state.graph.has(start)) return setOut(`Start node "${start}" not found.`);
  if (!state.graph.has(target)) return setOut(`Target node "${target}" not found.`);

  // BFS parent pointers
  const q = [start];
  const parent = new Map([[start, null]]);
  const trace = [];
  trace.push(`Shortest path (unweighted) via BFS`);
  trace.push(`start=${start}, target=${target}`);
  trace.push(`queue = [${q.join(", ")}]`);

  while (q.length) {
    const cur = q.shift();
    trace.push(`pop ${cur}`);
    if (cur === target) break;

    for (const nxt of neighbors(cur)) {
      if (!parent.has(nxt)) {
        parent.set(nxt, cur);
        q.push(nxt);
        trace.push(`  set parent[${nxt}] = ${cur}, enqueue`);
      }
    }
    trace.push(`queue = [${q.join(", ")}]`);
  }

  if (!parent.has(target)) {
    setOut(`No path found from ${start} to ${target}.`, trace.join("\n"));
    animateVisit(Array.from(parent.keys()));
    return;
  }

  // Reconstruct path from target back to start
  const path = [];
  let cur = target;
  while (cur !== null) {
    path.push(cur);
    cur = parent.get(cur);
  }
  path.reverse();

  setOut(`Shortest path: ${path.join(" -> ")} (edges: ${path.length - 1})`, trace.join("\n"));
  animateVisit(path);
}

function runComponents() {
  rebuildIfDirty();
  if (state.mode !== "graph") return setOut("Connected components are for graphs. Switch to Graph mode.");

  const visited = new Set();
  const comps = [];
  const trace = [];

  const all = Array.from(state.graph.keys()).sort();
  for (const node of all) {
    if (visited.has(node)) continue;

    const comp = [];
    const q = [node];
    visited.add(node);

    trace.push(`Component seed: ${node}`);
    while (q.length) {
      const cur = q.shift();
      comp.push(cur);
      for (const nxt of neighbors(cur)) {
        if (!visited.has(nxt)) {
          visited.add(nxt);
          q.push(nxt);
        }
      }
    }
    comps.push(comp);
  }

  const outLines = comps.map((c, i) => `C${i+1}: { ${c.join(", ")} }`);
  setOut(`Connected components: ${comps.length}\n` + outLines.join("\n"), trace.join("\n"));
  animateVisit(comps.flat());
}

function runCycleDetect() {
  rebuildIfDirty();
  if (state.mode !== "graph") return setOut("Cycle detection here is for undirected graphs. Switch to Graph mode.");
  if (!state.undirected) return setOut("This cycle detector expects an UNDIRECTED graph. Toggle 'Undirected' on.");

  const visited = new Set();
  const trace = [];

  // DFS with parent tracking
  function hasCycle(start) {
    const stack = [[start, null]]; // [node, parent]
    while (stack.length) {
      const [cur, parent] = stack.pop();
      if (!visited.has(cur)) {
        visited.add(cur);
        trace.push(`visit ${cur} (parent=${parent ?? "null"})`);
        for (const nxt of neighbors(cur)) {
          if (!visited.has(nxt)) {
            stack.push([nxt, cur]);
          } else if (nxt !== parent) {
            trace.push(`cycle found: edge ${cur} - ${nxt} (back to visited, not parent)`);
            return true;
          }
        }
      }
    }
    return false;
  }

  let cycle = false;
  const all = Array.from(state.graph.keys()).sort();
  for (const node of all) {
    if (!visited.has(node)) {
      if (hasCycle(node)) { cycle = true; break; }
    }
  }

  setOut(`Cycle detected (undirected): ${cycle ? "YES" : "NO"}`, trace.join("\n"));
  animateVisit(Array.from(visited));
}

function runTreeTraversal(kind) {
  rebuildIfDirty();
  if (state.mode !== "tree") return setOut("Switch to Tree mode to run tree traversals.");

  const root = el.startNode.value.trim();
  if (!root) return setOut("Enter a root node in Start node.");
  if (!state.tree.has(root)) return setOut(`Root "${root}" not found in tree.`);

  const trace = [];
  const order = [];

  if (kind === "pre") {
    trace.push(`Preorder (Root, Left, Right)`);
    preorder(root);
  } else if (kind === "in") {
    trace.push(`Inorder (Left, Root, Right)`);
    inorder(root);
  } else if (kind === "post") {
    trace.push(`Postorder (Left, Right, Root)`);
    postorder(root);
  } else if (kind === "level") {
    trace.push(`Level-order (BFS on tree)`);
    levelorder(root);
  }

  setOut(`${kind.toUpperCase()} traversal: ${order.join(" -> ")}`, trace.join("\n"));
  animateVisit(order);

  function preorder(node) {
    if (!node) return;
    order.push(node); trace.push(`visit ${node}`);
    const { left, right } = state.tree.get(node) || {};
    preorder(left);
    preorder(right);
  }
  function inorder(node) {
    if (!node) return;
    const { left, right } = state.tree.get(node) || {};
    inorder(left);
    order.push(node); trace.push(`visit ${node}`);
    inorder(right);
  }
  function postorder(node) {
    if (!node) return;
    const { left, right } = state.tree.get(node) || {};
    postorder(left);
    postorder(right);
    order.push(node); trace.push(`visit ${node}`);
  }
  function levelorder(node) {
    const q = [node];
    while (q.length) {
      const cur = q.shift();
      order.push(cur); trace.push(`visit ${cur}`);
      const { left, right } = state.tree.get(cur) || {};
      if (left) q.push(left);
      if (right) q.push(right);
    }
  }
}

function rebuildIfDirty() {
  // Simple approach: always rebuild before run so input edits reflect immediately.
  rebuild();
}

function setOut(main, trace="") {
  el.output.textContent = main || "";
  el.trace.textContent = trace || "";
}

function computeLayout() {
  state.positions.clear();
  if (state.nodes.length === 0) return;

  if (state.mode === "tree") {
    // Simple tree layout: BFS levels based on root
    const root = el.startNode.value.trim();
    const levels = new Map(); // node -> depth
    const parent = new Map();
    if (root && state.tree.has(root)) {
      const q = [root];
      levels.set(root, 0);
      parent.set(root, null);
      while (q.length) {
        const cur = q.shift();
        const depth = levels.get(cur);
        const { left, right } = state.tree.get(cur) || {};
        for (const child of [left, right]) {
          if (child && !levels.has(child)) {
            levels.set(child, depth + 1);
            parent.set(child, cur);
            q.push(child);
          }
        }
      }
    }

    // group by depth
    const byDepth = new Map();
    for (const n of state.nodes) {
      const d = levels.has(n) ? levels.get(n) : 0;
      if (!byDepth.has(d)) byDepth.set(d, []);
      byDepth.get(d).push(n);
    }

    const depths = Array.from(byDepth.keys()).sort((a,b)=>a-b);
    const maxDepth = depths.length ? Math.max(...depths) : 0;

    const padX = 80, padY = 70;
    const w = 1000 - padX*2;
    const h = 520 - padY*2;

    for (const d of depths) {
      const arr = byDepth.get(d).sort();
      const y = padY + (maxDepth === 0 ? h/2 : (d / maxDepth) * h);
      for (let i = 0; i < arr.length; i++) {
        const x = padX + (arr.length === 1 ? w/2 : (i / (arr.length - 1)) * w);
        state.positions.set(arr[i], { x, y });
      }
    }
    // nodes not connected from root: put them on bottom line
    for (const n of state.nodes) {
      if (!state.positions.has(n)) {
        state.positions.set(n, { x: 80 + Math.random()*840, y: 480 });
      }
    }
  } else {
    // Graph layout: circle
    const cx = 500, cy = 260, r = 190;
    const n = state.nodes.length;
    for (let i = 0; i < n; i++) {
      const angle = (Math.PI * 2 * i) / n;
      const x = cx + r * Math.cos(angle);
      const y = cy + r * Math.sin(angle);
      state.positions.set(state.nodes[i], { x, y });
    }
  }
}

function draw(highlightOrder) {
  const svg = el.viz;
  while (svg.firstChild) svg.removeChild(svg.firstChild);

  // defs
  const defs = document.createElementNS(svg.namespaceURI, "defs");
  defs.innerHTML = `
    <filter id="glow">
      <feGaussianBlur stdDeviation="2.5" result="coloredBlur"/>
      <feMerge>
        <feMergeNode in="coloredBlur"/>
        <feMergeNode in="SourceGraphic"/>
      </feMerge>
    </filter>
  `;
  svg.appendChild(defs);

  const visitedIndex = new Map();
  highlightOrder.forEach((n, i) => visitedIndex.set(n, i));

  // edges
  for (const [u, v] of state.edges) {
    const pu = state.positions.get(u);
    const pv = state.positions.get(v);
    if (!pu || !pv) continue;

    const line = document.createElementNS(svg.namespaceURI, "line");
    line.setAttribute("x1", pu.x);
    line.setAttribute("y1", pu.y);
    line.setAttribute("x2", pv.x);
    line.setAttribute("y2", pv.y);
    line.setAttribute("stroke", "rgba(232,238,255,.35)");
    line.setAttribute("stroke-width", "2");
    svg.appendChild(line);
  }

  // nodes
  for (const node of state.nodes) {
    const p = state.positions.get(node);
    if (!p) continue;

    const idx = visitedIndex.has(node) ? visitedIndex.get(node) : null;
    const isVisited = idx !== null;

    const g = document.createElementNS(svg.namespaceURI, "g");

    const circle = document.createElementNS(svg.namespaceURI, "circle");
    circle.setAttribute("cx", p.x);
    circle.setAttribute("cy", p.y);
    circle.setAttribute("r", "22");
    circle.setAttribute("stroke-width", "2");

    if (isVisited) {
      circle.setAttribute("fill", "rgba(122,162,255,.25)");
      circle.setAttribute("stroke", "rgba(122,162,255,.9)");
      circle.setAttribute("filter", "url(#glow)");
    } else {
      circle.setAttribute("fill", "rgba(255,255,255,.07)");
      circle.setAttribute("stroke", "rgba(255,255,255,.22)");
    }

    const text = document.createElementNS(svg.namespaceURI, "text");
    text.setAttribute("x", p.x);
    text.setAttribute("y", p.y + 5);
    text.setAttribute("text-anchor", "middle");
    text.setAttribute("font-size", "14");
    text.setAttribute("fill", "rgba(232,238,255,.95)");
    text.setAttribute("font-family", "ui-monospace, Menlo, Monaco, Consolas, monospace");
    text.textContent = node;

    const badge = document.createElementNS(svg.namespaceURI, "text");
    badge.setAttribute("x", p.x);
    badge.setAttribute("y", p.y - 28);
    badge.setAttribute("text-anchor", "middle");
    badge.setAttribute("font-size", "11");
    badge.setAttribute("fill", "rgba(169,182,232,.95)");
    badge.setAttribute("font-family", "ui-monospace, Menlo, Monaco, Consolas, monospace");
    badge.textContent = isVisited ? `#${idx+1}` : "";

    g.appendChild(circle);
    g.appendChild(text);
    g.appendChild(badge);
    svg.appendChild(g);
  }
}

function animateVisit(order) {
  // simple animation: reveal visited nodes over time
  const full = order.slice();
  let i = 0;
  const step = () => {
    draw(full.slice(0, i));
    i++;
    if (i <= full.length) requestAnimationFrame(() => setTimeout(step, 180));
  };
  step();
}
</script>
</body>
</html>
